# Practice 10

## 1. В чём отличие измерения времени выполнения от профилирования?

Измерение времени выполнения показывает, сколько программа работает в целом или сколько занимает отдельный участок кода. Это даёт общее представление о скорости, но не объясняет причины.
Профилирование идёт глубже: оно показывает, где именно тратится время, какие функции вызываются чаще всего, где возникают простои, ожидания или проблемы с памятью. По сути, тайминг отвечает на вопрос сколько, а профилирование — почему именно так.

---

## 2. Какие виды узких мест характерны для CPU, GPU и распределённых программ?

Для CPU-программ узкими местами часто становятся последовательные участки кода, плохое использование кэша и большое количество ветвлений.
На GPU типичны ограничения по пропускной способности памяти, частые синхронизации и дивергенция потоков, когда разные потоки выполняют разные ветки кода.
В распределённых программах основными узкими местами являются задержки сети, объём передаваемых данных и ожидание синхронизации между узлами.

---

## 3. Почему увеличение числа потоков или процессов не всегда приводит к ускорению?

Увеличение числа потоков повышает накладные расходы на управление ими и синхронизацию. Если задача содержит значительную последовательную часть или потоки часто ждут доступ к общим данным, дополнительный параллелизм не даёт выигрыша. В итоге система тратит больше времени на координацию, чем на реальные вычисления.

---

## 4. Как законы Амдала и Густафсона применяются при анализе масштабируемости?

Закон Амдала показывает, что ускорение программы ограничено долей последовательного кода. Даже небольшая непараллелизуемая часть со временем становится главным тормозом при увеличении числа процессоров.
Закон Густафсона смотрит на проблему с другой стороны: если увеличивать размер задачи вместе с числом вычислительных ресурсов, то эффективность масштабирования может сохраняться. Вместе эти законы помогают понять, где параллелизм действительно оправдан, а где его потенциал ограничен.

---

## 5. Какие факторы наиболее критичны для производительности гибридных приложений?

Для гибридных приложений ключевыми факторами являются баланс нагрузки между CPU и GPU, стоимость передачи данных между ними и количество точек синхронизации. Неправильное распределение работы может привести к тому, что одно устройство простаивает, ожидая другое. Также критичны выбор алгоритма и эффективность работы с памятью на каждом уровне системы.
